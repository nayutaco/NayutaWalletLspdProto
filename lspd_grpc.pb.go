// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package NayutaHub2LspdProto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LightningServiceClient is the client API for LightningService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LightningServiceClient interface {
	/// Ping/Pong
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error)
	/// Get LSP information
	ChannelInformation(ctx context.Context, in *ChannelInformationRequest, opts ...grpc.CallOption) (*ChannelInformationReply, error)
	/// Open private zero-conf channel
	OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error)
	/// [on-the-fly]Register a on-the-fly channel creation information
	RegisterPayment(ctx context.Context, in *RegisterPaymentRequest, opts ...grpc.CallOption) (*RegisterPaymentReply, error)
	/// [submarine swap]Register a Submarine Swap information
	RegisterSubmarine(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error)
	/// [submarine swap]Request starting Submarine Swap
	ReceiveSubmarine(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*ReceiveSubmarineReply, error)
	/// []Request query routes
	QueryRoutes(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error)
	/// Register user mail address
	RegisterUserInfo(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*RegisterUserInfoReply, error)
	/// Report message
	ReportMessage(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*ReportReply, error)
	/// Integrity get nonce message
	IntegrityNonce(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error)
	/// Integrity Verify message
	IntegrityVerify(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*IntegrityVerifyReply, error)
}

type lightningServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLightningServiceClient(cc grpc.ClientConnInterface) LightningServiceClient {
	return &lightningServiceClient{cc}
}

func (c *lightningServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingReply, error) {
	out := new(PingReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) ChannelInformation(ctx context.Context, in *ChannelInformationRequest, opts ...grpc.CallOption) (*ChannelInformationReply, error) {
	out := new(ChannelInformationReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/ChannelInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) OpenChannel(ctx context.Context, in *OpenChannelRequest, opts ...grpc.CallOption) (*OpenChannelReply, error) {
	out := new(OpenChannelReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/OpenChannel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) RegisterPayment(ctx context.Context, in *RegisterPaymentRequest, opts ...grpc.CallOption) (*RegisterPaymentReply, error) {
	out := new(RegisterPaymentReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/RegisterPayment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) RegisterSubmarine(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error) {
	out := new(Encrypted)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/RegisterSubmarine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) ReceiveSubmarine(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*ReceiveSubmarineReply, error) {
	out := new(ReceiveSubmarineReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/ReceiveSubmarine", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) QueryRoutes(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error) {
	out := new(Encrypted)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/QueryRoutes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) RegisterUserInfo(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*RegisterUserInfoReply, error) {
	out := new(RegisterUserInfoReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/RegisterUserInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) ReportMessage(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*ReportReply, error) {
	out := new(ReportReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/ReportMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) IntegrityNonce(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*Encrypted, error) {
	out := new(Encrypted)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/IntegrityNonce", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lightningServiceClient) IntegrityVerify(ctx context.Context, in *Encrypted, opts ...grpc.CallOption) (*IntegrityVerifyReply, error) {
	out := new(IntegrityVerifyReply)
	err := c.cc.Invoke(ctx, "/lspd.LightningService/IntegrityVerify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LightningServiceServer is the server API for LightningService service.
// All implementations must embed UnimplementedLightningServiceServer
// for forward compatibility
type LightningServiceServer interface {
	/// Ping/Pong
	Ping(context.Context, *PingRequest) (*PingReply, error)
	/// Get LSP information
	ChannelInformation(context.Context, *ChannelInformationRequest) (*ChannelInformationReply, error)
	/// Open private zero-conf channel
	OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error)
	/// [on-the-fly]Register a on-the-fly channel creation information
	RegisterPayment(context.Context, *RegisterPaymentRequest) (*RegisterPaymentReply, error)
	/// [submarine swap]Register a Submarine Swap information
	RegisterSubmarine(context.Context, *Encrypted) (*Encrypted, error)
	/// [submarine swap]Request starting Submarine Swap
	ReceiveSubmarine(context.Context, *Encrypted) (*ReceiveSubmarineReply, error)
	/// []Request query routes
	QueryRoutes(context.Context, *Encrypted) (*Encrypted, error)
	/// Register user mail address
	RegisterUserInfo(context.Context, *Encrypted) (*RegisterUserInfoReply, error)
	/// Report message
	ReportMessage(context.Context, *Encrypted) (*ReportReply, error)
	/// Integrity get nonce message
	IntegrityNonce(context.Context, *Encrypted) (*Encrypted, error)
	/// Integrity Verify message
	IntegrityVerify(context.Context, *Encrypted) (*IntegrityVerifyReply, error)
	mustEmbedUnimplementedLightningServiceServer()
}

// UnimplementedLightningServiceServer must be embedded to have forward compatible implementations.
type UnimplementedLightningServiceServer struct {
}

func (UnimplementedLightningServiceServer) Ping(context.Context, *PingRequest) (*PingReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedLightningServiceServer) ChannelInformation(context.Context, *ChannelInformationRequest) (*ChannelInformationReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChannelInformation not implemented")
}
func (UnimplementedLightningServiceServer) OpenChannel(context.Context, *OpenChannelRequest) (*OpenChannelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenChannel not implemented")
}
func (UnimplementedLightningServiceServer) RegisterPayment(context.Context, *RegisterPaymentRequest) (*RegisterPaymentReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterPayment not implemented")
}
func (UnimplementedLightningServiceServer) RegisterSubmarine(context.Context, *Encrypted) (*Encrypted, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSubmarine not implemented")
}
func (UnimplementedLightningServiceServer) ReceiveSubmarine(context.Context, *Encrypted) (*ReceiveSubmarineReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReceiveSubmarine not implemented")
}
func (UnimplementedLightningServiceServer) QueryRoutes(context.Context, *Encrypted) (*Encrypted, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryRoutes not implemented")
}
func (UnimplementedLightningServiceServer) RegisterUserInfo(context.Context, *Encrypted) (*RegisterUserInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterUserInfo not implemented")
}
func (UnimplementedLightningServiceServer) ReportMessage(context.Context, *Encrypted) (*ReportReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportMessage not implemented")
}
func (UnimplementedLightningServiceServer) IntegrityNonce(context.Context, *Encrypted) (*Encrypted, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntegrityNonce not implemented")
}
func (UnimplementedLightningServiceServer) IntegrityVerify(context.Context, *Encrypted) (*IntegrityVerifyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IntegrityVerify not implemented")
}
func (UnimplementedLightningServiceServer) mustEmbedUnimplementedLightningServiceServer() {}

// UnsafeLightningServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LightningServiceServer will
// result in compilation errors.
type UnsafeLightningServiceServer interface {
	mustEmbedUnimplementedLightningServiceServer()
}

func RegisterLightningServiceServer(s grpc.ServiceRegistrar, srv LightningServiceServer) {
	s.RegisterService(&LightningService_ServiceDesc, srv)
}

func _LightningService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_ChannelInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelInformationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).ChannelInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/ChannelInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).ChannelInformation(ctx, req.(*ChannelInformationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_OpenChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenChannelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).OpenChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/OpenChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).OpenChannel(ctx, req.(*OpenChannelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_RegisterPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).RegisterPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/RegisterPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).RegisterPayment(ctx, req.(*RegisterPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_RegisterSubmarine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).RegisterSubmarine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/RegisterSubmarine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).RegisterSubmarine(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_ReceiveSubmarine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).ReceiveSubmarine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/ReceiveSubmarine",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).ReceiveSubmarine(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_QueryRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).QueryRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/QueryRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).QueryRoutes(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_RegisterUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).RegisterUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/RegisterUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).RegisterUserInfo(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_ReportMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).ReportMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/ReportMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).ReportMessage(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_IntegrityNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).IntegrityNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/IntegrityNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).IntegrityNonce(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

func _LightningService_IntegrityVerify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Encrypted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LightningServiceServer).IntegrityVerify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/lspd.LightningService/IntegrityVerify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LightningServiceServer).IntegrityVerify(ctx, req.(*Encrypted))
	}
	return interceptor(ctx, in, info, handler)
}

// LightningService_ServiceDesc is the grpc.ServiceDesc for LightningService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LightningService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lspd.LightningService",
	HandlerType: (*LightningServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _LightningService_Ping_Handler,
		},
		{
			MethodName: "ChannelInformation",
			Handler:    _LightningService_ChannelInformation_Handler,
		},
		{
			MethodName: "OpenChannel",
			Handler:    _LightningService_OpenChannel_Handler,
		},
		{
			MethodName: "RegisterPayment",
			Handler:    _LightningService_RegisterPayment_Handler,
		},
		{
			MethodName: "RegisterSubmarine",
			Handler:    _LightningService_RegisterSubmarine_Handler,
		},
		{
			MethodName: "ReceiveSubmarine",
			Handler:    _LightningService_ReceiveSubmarine_Handler,
		},
		{
			MethodName: "QueryRoutes",
			Handler:    _LightningService_QueryRoutes_Handler,
		},
		{
			MethodName: "RegisterUserInfo",
			Handler:    _LightningService_RegisterUserInfo_Handler,
		},
		{
			MethodName: "ReportMessage",
			Handler:    _LightningService_ReportMessage_Handler,
		},
		{
			MethodName: "IntegrityNonce",
			Handler:    _LightningService_IntegrityNonce_Handler,
		},
		{
			MethodName: "IntegrityVerify",
			Handler:    _LightningService_IntegrityVerify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "lspd.proto",
}
